// Set to 6.0 scripting object model (Indesign CS4)app.scriptPreferences.version = 6.0;// ReattachPages.jsx// Gets the user to choose a folder and tries to make one InDesign document// from all the pages in all the InDesign documents in that folder, // ordered by page number.  If any of the pages don't have their own page numbers,// the script asks the user to try again.// For now, this method assumes that you want// to apply a section to a page and make that page// the start of the section.Section.prototype.duplicate = function (myNewPage) {  var mySection = this;  var mySectionPropertyList = [                               "includeSectionPrefix",                               "name",                               "label",                               "marker",                               "pageNumberStyle",                               "pageNumberStart",                               "continueNumbering",                              ];  var myNewSection = myNewPage.appliedSection;  var myNewDoc = myNewPage.parent.parent;    if (myNewPage != myNewSection.pageStart) {    myNewSection = myNewDoc.sections.add (myNewPage);  }  var p;  while (mySectionPropertyList.length) {    p = mySectionPropertyList.pop();    if (p!== null && p !== undefined) {      myNewSection[p] = mySection[p];    }  }}Spread.prototype.freezePageNumbering = Document.prototype.freezePageNumbering = function () {  for (var i = 0; i < this.pages.length; i++) {    this.pages[i].freezePageNumbering();  }}Application.prototype.openWithoutWarnings = function (myFile, myShowingWindow) {  if (arguments.length < 2) {    var myShowingWindow = true; // default  }  // Avoid random dialog alerts (missing fonts, picture links, etc.) when opening the file.  this.scriptPreferences.userInteractionLevel = UserInteractionLevels.neverInteract;  this.open(myFile, myShowingWindow);  // defaults to opening a window with the document.  // Restore user interaction  app.scriptPreferences.userInteractionLevel = UserInteractionLevels.interactWithAll;}  Page.prototype.freezePageNumbering = function () {  var myPage = this;  var myDoc = myPage.parent.parent;  var mySection = myPage.appliedSection;  var myPageNum = mySection.pageNumberStart                              + myPage.documentOffset                              - mySection.pageStart.documentOffset;  var mySectionPropertyList = [                               "includeSectionPrefix",                               "name",                               "label",                               "marker",                               "pageNumberStyle",                              ];  var myNewSection;  if (myPage == mySection.pageStart) {    myNewSection = mySection;  }  else {    myNewSection = myDoc.sections.add(myPage);  }  var p;  while (mySectionPropertyList.length) {    p = mySectionPropertyList.pop();    if (p!== null && p !== undefined) {      myNewSection[p] = mySection[p];    }  }  myNewSection.continueNumbering = false;  myNewSection.pageNumberStart = myPageNum;}Spread.prototype.freezePageNumbering = Document.prototype.freezePageNumbering = function () {  for (var i = 0; i < this.pages.length; i++) {    this.pages[i].freezePageNumbering();  }}Application.prototype.openWithoutWarnings = function (myFile, myShowingWindow) {  if (arguments.length < 2) {    var myShowingWindow = true; // default  }  // Avoid random dialog alerts (missing fonts, picture links, etc.) when opening the file.  this.scriptPreferences.userInteractionLevel = UserInteractionLevels.neverInteract;  this.open(myFile, myShowingWindow);  // defaults to opening a window with the document.  // Restore user interaction  app.scriptPreferences.userInteractionLevel = UserInteractionLevels.interactWithAll;}    main();function main() {    var myFolder;  var myFileArray = [];  var i;  var j;  var myFileNameForDisplay;    var myPageArray = [];  var foundBadPages;  var myPage, mySection;  var nyNewPage, myNewSection;  var myPageItem;  var errorString;    var myDoc;  var myNewDoc;  var myNewFile, myNewFileName, myNewFilePathName;  var myRandomStemFile;    var myPreJumpParagraphStyleName = "Jumpline >";  var myPostJumpParagraphStyleName = "Jumpline <";  var myJumpSlugFontName = "Glypha";  var myPageNumberFontName = "ITC Slimbach";    if (app.documents.length > 0) error_exit ("Please close all InDesign documents and try again.");    // Get the folder where all the InDesign files are supposed to be.  myFolder = Folder.selectDialog("Please select a folder containing all the InDesign files you want to reattach to each other.");  if (myFolder == null) exit ();    // Get the name of the new file where all the pages will go.  myNewFile = myFolder.saveDlg("Please select a name and location for the new InDesign document which will contained the reattached pages.");  if (myNewFile == null) exit();  myNewFileName = myNewFile.name;  myNewFilePathName = myNewFile.path;  myNewFile.close();    // add ".indd" at the end if it's not already there, and check if it can be overwritten.    myNewFileName = myNewFileName.replace (/\.indd$/, "") + ".indd";  myNewFile = new File (myNewFilePathName + "/" + myNewFileName);  if (myNewFile.exists) {      if (unescape (myNewFilePathName) == myFolder.fullName) {          myNewFile.close();          error_exit (unescape (myNewFileName) + "\r\r" + "already exists in the folder you've chosen to take your files from.  " +                          "Please try again, and either choose a different name for your file, or a different folder.");      }      else if (!confirm (unescape (myNewFileName) + " already exists.  Overwrite it?"))          exit();  }          // Get the list of files in the folder.  myFileArray = myFolder.getFiles("*");    // Remove all non-InDesign documents from the list.  for (i=myFileArray.length-1; i >= 0; i--) {    if (myFileArray[i].creator != "InDn") {      myFileArray.splice (i, 1);    }  }    // Pick a random file in the folder to be a template for the new document.  myRandomStemFile = myFileArray[0];  // REFACTORING NOTE:  GO BACK AND FIGURE OUT HOW WE CAN _NOT_ OPEN A WINDOW WITH THIS DOCUMENT,   // AND GET A REFERENCE TO THE DOCUMENT SOMEHOW WITHOUT IT BEING THE ACTIVE DOCUMENT.  open_with_no_warnings (myRandomStemFile, true);  // Open a window with this document.  app.activeDocument.save(myNewFile);  myNewDoc = app.activeDocument;      for (i=myNewDoc.pages.length-1; i > 0; i--) {  // note i>0, not the usual i>=0.  We're removing all but one page (only because we can't remove that last page yet).    myNewDoc.pages[i].remove();  }  myNewDoc.spreads[0].allowPageShuffle = true;  myNewDoc.documentPreferences.allowPageShuffle = true;  myNewDoc.close (SaveOptions.YES, myNewFile);  // Now open all the original documents, freeze the page numbers,  // and make sure the spreads can shuffle.  open_with_no_warnings (myFileArray, false);  // Opens all these documents with no windows.  for (i = 0; i < app.documents.length; i++) {      myDoc = app.documents[i];    myDoc.freezePageNumbering();    // Delete hidden layers.    for (j = myDoc.layers.length-1; j>=0; j--) {      if (!myDoc.layers[j].visible) {        myDoc.layers[j].remove();      }    }    // Assemble the PageArray.    for (j = 0; j < myDoc.pages.length; j++) {      myPage = myDoc.pages[j];      myPageArray.push (myPage);    }  }    // Now order these pages numerically.  myPageArray.sort (pageCompare);    // Now copy them into the new document and erase one page that was there already.  // But before we copy them, detach all items from their master pages, and then sever the connection  // between the page itself and any master page.  open_with_no_warnings (myNewFile, true);  // show a window with this document  for (i = 0; i < myPageArray.length; i++) {    // Detach master page items    myPage = myPageArray[i];    for (j = myPage.masterPageItems.length - 1; j >= 0; j--) {      myPageItem = myPage.masterPageItems[j];      myPageItem.override(myPage);      myPageItem.detach();    }    // Detach the page itself from the master page    myPage.appliedMaster = NothingEnum.nothing;    // Copy the page into the new document.    myNewPage = myPage.duplicate (LocationOptions.after, myNewDoc.pages[-1]);    // Section.duplicate() is a user-defined method which copies all    // the attributes of the section into a new section and then applies    // that section to the argument of the method (a Page).    myNewSection = myPage.appliedSection.duplicate (myNewPage);  }  // Remove the original first page from the new document,  // that was left over from when we created it from a random document.  myNewDoc.pages[0].remove();    myNewDoc.save();  // Close all documents except the new one.  for (i = app.documents.length-1; i>=0; i--)     if (app.documents[i] != myNewDoc) app.documents[i].close(SaveOptions.NO);      // Make all layers visible.  We have to do this because trying to reattach the jumps   // has squirrelly effects if one is on a visible layer and one is on an invisible layer.  // Of course, all the layers should be visible since we deleted all invisible layers from the  // source files before we duplicated the pages into myNewDoc, but for some reason it makes some of the  // layers hidden in the new document, so we need to reveal them to the light of day.  for (i = myNewDoc.layers.length -1; i >= 0; i--) {    myNewDoc.layers[i].visible = true;  }    // Now we are done reattaching the pages.  It's time to reattach the jumps.   // This part is totally specific to the Forward Newspaper.  var myListOfPreJumps = myFindText(myNewDoc, {appliedParagraphStyle: myPreJumpParagraphStyleName}, undefined, undefined);  if (myListOfPreJumps != null) {    for (i = myListOfPreJumps.length-1; i >+ 0; i--) {      var myPreJump = myListOfPreJumps[i];      var myListOfJumpSlugs = myFindText (myPreJump, {appliedFont:  myJumpSlugFontName}, undefined, undefined);      if ((myListOfJumpSlugs == null) || (myListOfJumpSlugs.length == 0) || (myListOfJumpSlugs.length > 1)) {        myNewDoc.close(SaveOptions.NO);        myNewFile.remove();        error_exit ("There's something funny going on with one of the jump slugs.  Probably there is a " +              "space between two of the words in the bold Glypha jump name that has some other font style. " +              "Or maybe there's no bold Glypha story name in the jump slug.  Check them and try again.");      }      var myJumpSlug = myListOfJumpSlugs[0];      var myListOfPostJumps = myFindText (myNewDoc,                   {findWhat: myJumpSlug.contents, appliedParagraphStyle: myPostJumpParagraphStyleName},                   undefined, {caseSensitive: false, includeHiddenLayers: true});      if ((myListOfPostJumps != null) && (myListOfPostJumps.length > 0)) {        if (myListOfPostJumps.length > 1) {          myNewDoc.close(SaveOptions.NO);          myNewFile.remove();          error_exit ("There was more than one place that this jump slug jumped to.  " +                "Please examine this problem, and after careful consideration, try again.");        }        else {          var myPostJump = myListOfPostJumps[0];          var myPreJumpStory = myPreJump.parentStory;          var myPostJumpStory = myPostJump.parentStory;                    // Now that we have pre-jump and post-jump, reattach them.                    // First make sure they're not in the same story, like in a jumplines template box.          if (myPreJumpStory != myPostJumpStory) {            // Make the page numbers automatic again.  Search only for digits that are in the page number font,            // on the slim offchance that there are digits in the actual bold Glypha slug.            try {                  myFindGrep (myPreJumpStory.paragraphs[-1], {findWhat: "[0-9]*", appliedFont: myPageNumberFontName}, {changeTo: "#"}, undefined);                  myPreJumpStory.paragraphs[-1].characters[myPreJumpStory.paragraphs[-1].contents.indexOf("#")].contents = SpecialCharacters.nextPageNumber;                  myFindGrep (myPostJumpStory.paragraphs[0], {findWhat: "[0-9]*", appliedFont: myPageNumberFontName}, {changeTo: "#"}, undefined);                  myPostJumpStory.paragraphs[0].characters[myPostJumpStory.paragraphs[0].contents.indexOf("#")].contents = SpecialCharacters.previousPageNumber;            }             catch (e) {                alert ("We were not able to convert all of the page numbers in the jump slugs into automatic page numbers " +                    "(and, in fact, some of them may have been converted into \"#\" symbols -- I'd check that), " +                    "but everything else should be fine.");            }            // Now add a final paragraph break to the preJumpStory if there isn't one already.            if (myPreJumpStory.characters[-1] != "\r")               myPreJumpStory.insertionPoints[-1].contents = "\r";            myPostJumpStory.textContainers[0].previousTextFrame = myPreJumpStory.textContainers[myPreJumpStory.textContainers.length-1];          }        }      }    }  }  myNewDoc.save();}  // pageCompare is intended to be used with the Array.sort method.    function pageCompare (pageA, pageB, /*bool*/useHiddenSectionPrefixes) {   // First populate pageNumberStyleOrder so that it is an  // array whose keys are pageNumberStyle values,  // and whose values are whole numbers counting up from zero.  // This code would be a lot simpler if Javascript  // had a function to swap keys for values in an array.  var pageNumberStyleOrder = [];  var tempArray = [                   PageNumberStyle.LOWER_ROMAN,                   PageNumberStyle.UPPER_ROMAN,                   PageNumberStyle.LOWER_LETTERS,                   PageNumberStyle.UPPER_LETTERS,                   PageNumberStyle.ARABIC,                   PageNumberStyle.SINGLE_LEADING_ZEROS,                   PageNumberStyle.DOUBLE_LEADING_ZEROS,                   PageNumberStyle.TRIPLE_LEADING_ZEROS,                   PageNumberStyle.ARABIC_ABJAD,                   PageNumberStyle.ARABIC_ALIF_BA_TAH,                   PageNumberStyle.HEBREW_NON_STANDARD,                   PageNumberStyle.HEBREW_BIBLICAL,                  ];  var i=0;  while (tempArray.length) {    pageNumberStyleOrder[tempArray.shift()] = i;    i++;  }  var sectionA = pageA.appliedSection;  var sectionB = pageB.appliedSection;  var pageNumberStyleA = sectionA.pageNumberStyle;  var pageNumberStyleB = sectionB.pageNumberStyle;  var prefixA = sectionA.name;  var prefixB = sectionB.name;  var pageNumberA = sectionA.pageNumberStart                  + pageA.documentOffset                  - sectionA.pageStart.documentOffset;  var pageNumberB = sectionB.pageNumberStart                  + pageB.documentOffset                  - sectionB.pageStart.documentOffset;  if (arguments.length < 3) {      var useHiddenSectionPrefixes = true;  // default  }   // If useHiddenSectionPrefixes is false, treat all hidden section  // prefixes as if they were the empty string.  if (!useHiddenSectionPrefixes) {    if (!sectionA.includeSectionPrefix) prefixA = "";    if (!sectionB.includeSectionPrefix) prefixB = "";  }  // Sort by the prefix first,  // then by pageNumberStyleOrder,  // then by the page number within the section.  if (prefixA < prefixB) return -1;  if (prefixA > prefixB) return 1;  if (pageNumberStyleOrder[pageNumberStyleA] < pageNumberStyleOrder[pageNumberStyleB]) return -1;  if (pageNumberStyleOrder[pageNumberStyleA] > pageNumberStyleOrder[pageNumberStyleB]) return 1;  if (pageNumberA < pageNumberB) return -1;  if (pageNumberA > pageNumberB) return 1;  return 0;}function open_with_no_warnings (myFile, myShowingWindow) {  if (arguments.length < 2)     var myShowingWindow = true;  // Avoid random dialog alerts (missing fonts, picture links, etc.) when opening the file.  app.scriptPreferences.userInteractionLevel = UserInteractionLevels.neverInteract;  app.open(myFile, myShowingWindow);  // defaults to opening a window with the document.  // Restore user interaction  app.scriptPreferences.userInteractionLevel = UserInteractionLevels.interactWithAll;}  function error_exit (message) {  if (arguments.length > 0) alert (unescape(message));  exit();} // These next three functions are adaptations of the functions// that came with FindChangeByList.jsx, in the InDesign script samples.function myFindText(myObject, myFindPreferences, myChangePreferences, myFindChangeOptions){  //Reset the find/change preferences before each search.  app.changeTextPreferences = NothingEnum.nothing;  app.findTextPreferences = NothingEnum.nothing;  app.findTextPreferences.properties = myFindPreferences;  if (myChangePreferences) app.changeTextPreferences.properties = myChangePreferences;  if (myFindChangeOptions) app.findChangeTextOptions.properties = myFindChangeOptions;  var myFoundItems;  if (myChangePreferences) {    myFoundItems = myObject.changeText();  }  else {    myFoundItems = myObject.findText();  }  //Reset the find/change preferences after each search.  app.changeTextPreferences = NothingEnum.nothing;  app.findTextPreferences = NothingEnum.nothing;  return myFoundItems;}function myFindGrep(myObject, myFindPreferences, myChangePreferences, myFindChangeOptions){  //Reset the find/change grep preferences before each search.  app.changeGrepPreferences = NothingEnum.nothing;  app.findGrepPreferences = NothingEnum.nothing;  app.findGrepPreferences.properties = myFindPreferences;  if (myChangePreferences) app.changeGrepPreferences.properties = myChangePreferences;  if (myFindChangeOptions) app.findChangeGrepOptions.properties = myFindChangeOptions;  var myFoundItems;  if (myChangePreferences) {    myFoundItems = myObject.changeGrep();  }  else {    myFoundItems = myObject.findGrep();  }  //Reset the find/change grep preferences after each search.  app.changeGrepPreferences = NothingEnum.nothing;  app.findGrepPreferences = NothingEnum.nothing;  return myFoundItems;}function myFindGlyph(myObject, myFindPreferences, myChangePreferences, myFindChangeOptions){  //Reset the find/change glyph preferences before each search.  app.changeGlyphPreferences = NothingEnum.nothing;  app.findGlyphPreferences = NothingEnum.nothing;  app.findGlyphPreferences.properties;  if (myChangePreferences) app.changeGlyphPreferences.properties;  if (myFindChangeOptions) app.findChangeGlyphOptions.properties;  if (myChangePreferences) {    myFoundItems = myObject.changeGlyph();  }  else {    myFoundItems = myObject.findGlyph();  }  //Reset the find/change glyph preferences after each search.  app.changeGlyphPreferences = NothingEnum.nothing;  app.findGlyphPreferences = NothingEnum.nothing;  return myFoundItems;}    