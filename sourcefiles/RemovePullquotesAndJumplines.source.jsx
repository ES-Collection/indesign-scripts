// Set to 6.0 scripting object model (Indesign CS4)app.scriptPreferences.version = 6.0;// This is a modified version of ExportMarkdown, just to remove pullquotes and // jump lines from stories that are being prepared for reprint layouts.  // It does not export anything to an rtf file.  It just alters the text in // whatever box is selected when you run the script.// This was a quick hack. We'll fix it later./* This InDesign CS2 javascript takes a story that has been prepared for the print edition of the English Forward and processes it for parsing by Symphony, the content management system we use on our website.  Symphony will process files that are in properly-formed xhtml or in markdown (or a combination of both, as long as it can make sense of the input).  This script here goes the markdown route, because it's easier for people who are not familiar with html to read.  When the user runs the script, it whatever is selected and processes the parent story of that selection, whether the selection be a text frame, an insertion point, or a block of text.  It then asks for a filename from the user through a save dialog box.  It adds ".rtf" to the filename if necessary, and then it saves two versions of the story:  one unaltered just for reference, in the file "<user-supplied-filename>.rtf", and the other processed, in the file "√_<user-supplied-filename>.rtf".After the files have been saved, the script places the cursor at the beginning of the story, which has not been altered.------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Here is a list of the things that the script does:1.  It marks up bold and italic (and bold-italic) text.  In doing this, it IGNORES text style ranges that contain no alphanumeric characters.2.  It gets rid of the bullets at the beginning of book kickers and Forward Looking Back entries.3.  It styles drop caps as regular text, so they don't end up on separate lines from their stories.4.  It deletes pull quotes, jump lines, and extra paragraph breaks.5.  It converts the Philologos h-dots that Kurt and I use (which are just "h.", kerned and adjusted in such a way that the dot ends up below the h) into proper Unicode h-dots, which should display fine on the web.  Our font that we print the paper in does not have this character, which is why we have to do the workaround.  Most fonts used on the web do have the h-dot character, and if the user is using a font that doesn't, then the browser prints only that character in a font that does have it, so it will always display one way or another.6.  It makes the whole file double-spaced, meaning that it converts all occurrences of one paragraph break into two paragraph breaks.  Two paragraph breaks is the markdown version of an html paragraph tag.7.  It styles block quotes and poetry properly.  Intra-stanza line breaks are created in markdown format, which is two spaces at the end of the line followed by a single paragraph return.8.  It eliminates extra spaces in the text.------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Note:  The user should be reminded that if the outputs from these files are opened in Word, they might end up with gratuitious hyphens which Word actually puts into the text so that if you cut and paste it into Symphony, those hyphens will end up on the web page.  So they should turn off hyphenation in Word, or use TextEdit or something else that doesn't add hyphens.*/main();function main() {    var myMarkdown = { blockquote : ">",              lineBreak  : "  ",             fontStyles : {bold : "**", italic : "*"} };    var myBullets = { bookKicker : "l", forwardLookingBack : "✸" };    var myHDots = { capital: {representation: "H.", unicodeValue: "\u1E24"},            lowercase: {representation: "h.", unicodeValue: "\u1E25"} };         // A lot of times we'll be looking for any paragraph style that has a certain string in  // it, say the word "poetry".  These are those strings.  // REFACTORING NOTE:  PERHAPS IT MAKES MORE SENSE TO HAVE A LIST OF THE ACTUAL COMPLETE STYLES.  // THERE'S NOT THAT MANY OF THEM, AND IT MIGHT BE FASTER.  var myStyleStrings = {   pullquote: "pullquote", poetry: "poetry",               blockquote: "blockquote", bookKicker: "ARTS book",               forwardLookingBack: "FLB Body Copy", jumpline: "Jumpline",              suppressFontStyles: ["hed", "pt", "byline", "Philologos", "letter signature", "letters address"] };    var myFontStyleNameSegments = { bold : ["Bold", "Heavy", "Black", "Semibold", "Ultra"], italic : ["Italic", "Oblique"] };    var myRichTextFormat = "Rich Text Format";  var myAsterisk = "*";    // Case-insensitive search of an array of strings  function containsAny (myStr, mySearchWords) {    myStr = myStr.toLowerCase();    var i;    for (i=0; i < mySearchWords.length; i++) {      if (myStr.search(mySearchWords[i].toLowerCase()) != -1) {        return true;      }    }    return false;  }    function removeBlock (myStory, i, test, myParagraphStyleStrings) {    var removedSomething = false;    // The function removeBlock is not always testing for paragraph styles,     // so the second parameter of the passed function, test, is not always used.    while ((i < myStory.paragraphs.length) && (test (myStory.paragraphs[i], myParagraphStyleStrings))) { // second parameter of test here is not always used.      myStory.paragraphs[i].remove();      removedSomething = true;    }    return removedSomething;  }    function processStory (myStory) {    // The following if statement ensures that the script will work     // properly in the case of the last paragraph in the story, because     // the boundary case code for the end of each paragraph     // (WHICH BY THE WAY IS KIND OF SQUIRRELLY AND NEEDS TO BE    // REWRITTEN) requires a paragraph break at the end    // of every paragraph.    if (myStory.characters[-1].contents != "\r") {      myStory.insertionPoints[-1].contents = "\r";    }    // Similarly, get rid of all paragraph breaks at the very beginning of the story.    while (myStory.paragraphs[0].length == 1) {      myStory.paragraphs[0].remove();    }    // We increment by 1 in this version because no extra paragraph breaks are added.    var i;    for (i=0; i < myStory.paragraphs.length; i++) {      var myParagraph = myStory.paragraphs[i];      if (i+1 < myStory.paragraphs.length) {        var myNextParagraph = myStory.paragraphs[i+1];      }      else {        var myNextParagraph = 'end of story';      }            // 2.  Get rid of pullquotes and jumplines after this paragraph.      var testForStyles = function (paragraph, styleStrings) {        for (var str in styleStrings) {          if (paragraph.appliedParagraphStyle.name.search(styleStrings[str]) != -1) {            return true;          }        }        return false;      }      if (removeBlock (myStory, i+1, testForStyles, [myStyleStrings.pullquote, myStyleStrings.jumpline] )) {        // Concatenate paragraphs if they are supposed to read as one         // paragraph but were broken by pullquotes or jumplines.        // We don't have to check if we're at the end of the story, because         // pullquotes and jumplines would always have something after them.        if (myParagraph.justification == Justification.fullyJustified) {          // remove extra spaces at end of paragraph          while (myParagraph.characters[-2].contents == " ") {            myParagraph.characters[-2].contents = "";          }          myParagraph.justification = myStory.paragraphs[i+1].justification;          myParagraph.characters[-1].contents = " "; // one space                  }      }           }          // Get rid of the extra paragraph marks at the end of the story.    while (myStory.characters[-1].contents == '\r') myStory.characters[-1].contents = '';  }      var mySelection = app.selection[0];    if (typeof mySelection != 'undefined') {    switch (mySelection.constructor.name) {      case "Character":      case "Word":      case "TextStyleRange":      case "Line":      case "Paragraph":      case "TextColumn":      case "Text":      case "InsertionPoint" :      case "TextFrame" :                      var myStory = mySelection.parentStory;                processStory (myStory);              break;    }  }  else {    alert ("You need to select something.");  }                    function myFindText(myObject, myFindPreferences, myChangePreferences, myFindChangeOptions){    //Reset the find/change preferences before each search.    app.changeTextPreferences = NothingEnum.nothing;    app.findTextPreferences = NothingEnum.nothing;    app.findTextPreferences.properties = myFindPreferences;    if (myChangePreferences) app.changeTextPreferences.properties = myChangePreferences;    if (myFindChangeOptions) app.findChangeTextOptions.properties = myFindChangeOptions;    var myFoundItems;    if (myChangePreferences) {      myFoundItems = myObject.changeText();    }    else {      myFoundItems = myObject.findText();    }    //Reset the find/change preferences after each search.    app.changeTextPreferences = NothingEnum.nothing;    app.findTextPreferences = NothingEnum.nothing;    return myFoundItems;  }  function myFindGrep(myObject, myFindPreferences, myChangePreferences, myFindChangeOptions){    //Reset the find/change grep preferences before each search.    app.changeGrepPreferences = NothingEnum.nothing;    app.findGrepPreferences = NothingEnum.nothing;    app.findGrepPreferences.properties = myFindPreferences;    if (myChangePreferences) app.changeGrepPreferences.properties = myChangePreferences;    if (myFindChangeOptions) app.findChangeGrepOptions.properties = myFindChangeOptions;    var myFoundItems;    if (myChangePreferences) {      myFoundItems = myObject.changeGrep();    }    else {      myFoundItems = myObject.findGrep();    }    //Reset the find/change grep preferences after each search.    app.changeGrepPreferences = NothingEnum.nothing;    app.findGrepPreferences = NothingEnum.nothing;    return myFoundItems;  }  function myFindGlyph(myObject, myFindPreferences, myChangePreferences, myFindChangeOptions){    //Reset the find/change glyph preferences before each search.    app.changeGlyphPreferences = NothingEnum.nothing;    app.findGlyphPreferences = NothingEnum.nothing;    app.findGlyphPreferences.properties;    if (myChangePreferences) app.changeGlyphPreferences.properties;    if (myFindChangeOptions) app.findChangeGlyphOptions.properties;    if (myChangePreferences) {      myFoundItems = myObject.changeGlyph();    }    else {      myFoundItems = myObject.findGlyph();    }    //Reset the find/change glyph preferences after each search.    app.changeGlyphPreferences = NothingEnum.nothing;    app.findGlyphPreferences = NothingEnum.nothing;    return myFoundItems;  }        }  // end of main()/*// debugging text          if (!confirm ("Paragraph " + i +", TextStyleRange " + j + " contents : " + myParagraph.textStyleRanges[j].contents + "\r\r"                    + "myPreviousFontStyles['bold'] = " + myPreviousFontStyles['bold'] + "\r"                    + "myPreviousFontStyles['italic'] = " + myPreviousFontStyles['italic'] + "\r\r"                    + "myCurrentFontStyles['bold'] = " + myCurrentFontStyles['bold'] + "\r"                    + "myCurrentFontStyles['italic'] = " + myCurrentFontStyles['italic'])) {            return;          }// end debugging text           */